<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>í•™ìŠµë¶€ íƒ€ì›Œ ë””íœìŠ¤</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --ui-bg: rgba(30, 41, 59, 0.95);
            --accent: #38bdf8;
            --danger: #f43f5e;
            --success: #22c55e;
            --warning: #eab308;
            --text: #f1f5f9;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text);
            font-family: 'Gamja Flower', 'Segoe UI', Tahoma, sans-serif;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background: #020617;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .top-bar {
            padding: 10px;
            display: flex;
            justify-content: center;
            gap: 15px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            pointer-events: auto;
        }

        .stat-box {
            background: var(--ui-bg);
            padding: 6px 12px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9em;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        /* ë°°ì† ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        #speed-btn {
            cursor: pointer;
            transition: all 0.2s;
            background: #334155;
            min-width: 40px;
            justify-content: center;
        }
        #speed-btn:hover { background: #475569; transform: scale(1.1); }
        #speed-btn.active { background: var(--warning); color: #000; box-shadow: 0 0 10px var(--warning); }

        .bottom-bar {
            padding: 10px;
            display: flex;
            justify-content: center;
            gap: 4px;
            background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
            pointer-events: auto;
            flex-wrap: wrap;
            max-width: 1100px;
            margin: 0 auto;
            max-height: 180px;
            overflow-y: auto;
        }

        .bottom-bar::-webkit-scrollbar { display: none; }

        .tower-btn {
            background: var(--ui-bg);
            border: 2px solid transparent;
            border-radius: 6px;
            padding: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 48px;
            position: relative;
            margin-bottom: 4px;
        }

        .tower-btn:hover { transform: translateY(-3px); background: rgba(51, 65, 85, 1); }
        .tower-btn.selected { border-color: var(--accent); box-shadow: 0 0 10px var(--accent); }
        .tower-btn.disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }
        
        .tower-btn.btn-sell { border-color: #ef4444; }
        .tower-btn.btn-sell.selected { background: #7f1d1d; box-shadow: 0 0 10px #ef4444; }
        
        .tower-btn.btn-gacha { 
            border-color: #a855f7; 
            width: 60px;
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(88, 28, 135, 0.5));
        }
        .tower-btn.btn-gacha:hover { background: linear-gradient(135deg, #a855f7, #6366f1); }

        .tower-preview {
            width: 20px;
            height: 20px;
            margin-bottom: 2px;
            border-radius: 50%;
            border: 2px solid white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
        }

        .tower-info { font-size: 0.6em; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 100%; }
        .tower-cost { color: var(--warning); font-weight: bold; font-size: 0.8em; }
        
        .shortcut-key {
            position: absolute;
            top: 1px;
            left: 2px;
            font-size: 0.5em;
            opacity: 0.8;
            color: #fff;
            background: rgba(0,0,0,0.5);
            padding: 0 2px;
            border-radius: 2px;
        }

        .modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        #start-modal { display: flex; }

        .modal h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-transform: uppercase;
            background: linear-gradient(45deg, #ff00cc, #3333ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255, 0, 204, 0.5);
            text-align: center;
        }

        .modal p { font-size: 1.1em; margin-bottom: 20px; color: #cbd5e1; text-align: center; max-width: 600px; padding: 0 20px;}

        .diff-container { display: flex; gap: 15px; margin-top: 15px; }
        .btn-diff {
            padding: 12px 25px; font-size: 1.1em; border-radius: 12px; cursor: pointer; font-weight: bold; border: none; color: white; transition: transform 0.2s; text-transform: uppercase;
        }
        .btn-diff:hover { transform: scale(1.05); }
        .btn-easy { background: linear-gradient(45deg, #22c55e, #86efac); }
        .btn-normal { background: linear-gradient(45deg, #3b82f6, #93c5fd); }
        .btn-hard { background: linear-gradient(45deg, #ef4444, #fca5a5); }
        .btn-restart { margin-top: 20px; background: #eab308; color: #000; }
        .btn-next-stage { background: linear-gradient(45deg, #a855f7, #d8b4fe); }

        #quiz-modal-content {
            background: #1e293b; padding: 25px; border-radius: 15px; border: 2px solid var(--accent); max-width: 90%; width: 500px; text-align: center;
        }
        #quiz-question { font-size: 1.2em; margin-bottom: 15px; color: white; }
        .quiz-options { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .quiz-btn {
            background: #334155; color: #e2e8f0; border: 1px solid #475569; padding: 12px; border-radius: 8px; cursor: pointer; transition: all 0.2s;
        }
        .quiz-btn:hover { background: #475569; }
        .quiz-btn.correct { background: var(--success); color: white; }
        .quiz-btn.wrong { background: var(--danger); color: white; }

        .t-basic { background: #38bdf8; } .t-rapid { background: #facc15; } .t-ice { background: #60a5fa; }
        .t-sniper { background: #22c55e; } .t-flame { background: #f97316; } .t-splash { background: #f43f5e; }
        .t-tesla { background: #a855f7; } .t-laser { background: #d946ef; } .t-railgun { background: #06b6d4; }
        .t-nuke { background: #be123c; } .t-healer { background: #10b981; }
        .t-poison { background: #4ade80; } .t-multi { background: #e879f9; } .t-minigun { background: #94a3b8; }
        .t-buff { background: #fbbf24; } .t-blackhole { background: #1e293b; border: 2px solid #8b5cf6; }
        .t-meteor { background: #b91c1c; } .t-curse { background: #581c87; }
        .t-gold { background: #fcd34d; } .t-time { background: #2dd4bf; }
        .t-wind { background: #bae6fd; } .t-mortar { background: #713f12; } .t-shock { background: #fde047; }
        .t-execute { background: #991b1b; } .t-prism { background: linear-gradient(135deg, #f00, #0f0, #00f); }
        .t-soul { background: #312e81; } .t-speed { background: #ec4899; }

        @media (max-width: 600px) {
            .tower-btn { width: 42px; } .tower-info { display: none; } .shortcut-key { display: none; }
            .quiz-options { grid-template-columns: 1fr; } .diff-container { flex-direction: column; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="stat-box">â¤ï¸ <span id="lives-display">20</span></div>
            <div class="stat-box">ğŸ’° <span id="money-display">300</span></div>
            <div class="stat-box">ğŸŒŠ <span id="wave-display">1</span></div>
            <div class="stat-box">ğŸ—ºï¸ <span id="stage-display">1</span></div>
            <div class="stat-box" id="speed-btn" title="í€´ì¦ˆë¥¼ í’€ì–´ ë°°ì† ê¸°ëŠ¥ì„ í•´ê¸ˆí•˜ì„¸ìš”!">â–¶</div> <!-- New -->
        </div>
        <div class="bottom-bar"></div>
    </div>

    <div id="start-modal" class="modal">
        <h1 id="modal-title">í•™ìŠµë¶€ íƒ€ì›Œ ë””íœìŠ¤ ê²Œì„ (ì—­ì‚¬ ì§€í‚´ì´!)</h1>
        <p id="modal-desc">
            ì´ 27ì¢…ì˜ íƒ€ì›Œ! 300ì½”ì¸ìœ¼ë¡œ ëœë¤ ë½‘ê¸°ì— ë„ì „í•˜ì„¸ìš”!<br>
            <span style="color:#a855f7;">ğŸ² ë½‘ê¸°: 300G</span> (í•µí­íƒ„, ë©”í…Œì˜¤ í™•ë¥  0.5%!)<br>
            <span style="color:#f97316; font-size:0.9em;">ì£¼ì˜: ì£¼í™©ìƒ‰ ì (Breaker)ì€ íƒ€ì›Œë¥¼ ê³µê²©í•©ë‹ˆë‹¤.</span>
        </p>
        <p style="margin-bottom: 5px; color: var(--accent);">ë‚œì´ë„ë¥¼ ì„ íƒí•˜ì„¸ìš”</p>
        <div class="diff-container">
            <button class="btn-diff btn-easy" id="btn-easy">ì‰¬ì›€</button>
            <button class="btn-diff btn-normal" id="btn-normal">ë³´í†µ</button>
            <button class="btn-diff btn-hard" id="btn-hard">ì–´ë ¤ì›€</button>
        </div>
    </div>

    <div id="stage-modal" class="modal">
        <h1 style="color:#a855f7;">STAGE CLEAR!</h1>
        <p>ë‹¤ìŒ ì „ì¥ìœ¼ë¡œ ì´ë™í•  ì¤€ë¹„ê°€ ë˜ì…¨ìŠµë‹ˆê¹Œ?</p>
        <button class="btn-diff btn-next-stage" id="btn-next-stage">ë‹¤ìŒ ìŠ¤í…Œì´ì§€</button>
    </div>
    
    <div id="victory-modal" class="modal">
        <h1 style="color:#facc15;">VICTORY!</h1>
        <p>ëª¨ë“  ìŠ¤í…Œì´ì§€ë¥¼ ì •ë³µí•˜ê³  ì—­ì‚¬ë¥¼ ìˆ˜í˜¸í–ˆìŠµë‹ˆë‹¤!</p>
        <button class="btn-diff btn-restart" onclick="location.reload()">ì²˜ìŒë¶€í„° ë‹¤ì‹œ</button>
    </div>

    <div id="gameover-modal" class="modal">
        <h1>GAME OVER</h1>
        <p id="gameover-desc"></p>
        <button class="btn-diff btn-restart" onclick="location.reload()">ë‹¤ì‹œ ì‹œì‘</button>
    </div>

    <div id="quiz-modal" class="modal">
        <div id="quiz-modal-content">
            <h2 style="color:var(--warning); margin-top:0;">ì—­ì‚¬ í€´ì¦ˆ</h2>
            <p id="quiz-question">ë¬¸ì œ</p>
            <div class="quiz-options" id="quiz-options"></div>
        </div>
    </div>
</div>

<script>
// í€´ì¦ˆ ë°ì´í„° (ìƒëµ ì—†ì´ ì‚¬ìš©)
const HISTORY_QUIZ = [
    { q: "ì¡°ì„ ì„ ê±´êµ­í•œ ì¸ë¬¼ì€ ëˆ„êµ¬ì¸ê°€ìš”?", a: ["ì´ì„±ê³„", "ì™•ê±´", "ì´ë°©ì›", "ì •ë„ì „"], c: 0 },
    { q: "ì¡°ì„ ì˜ ë„ìì§€ë¡œ, í˜„ì¬ì˜ ì„œìš¸ì¸ ê³³ì˜ ì˜› ì´ë¦„ì€?", a: ["í•œì–‘", "ê°œê²½", "ì„œë¼ë²Œ", "ì›…ì§„"], c: 0 },
    { q: "ì„¸ì¢…ëŒ€ì™•ì´ ë°±ì„±ì„ ìœ„í•´ ë§Œë“  ê¸€ìëŠ”?", a: ["í›ˆë¯¼ì •ìŒ", "ì´ë‘", "í–¥ì°°", "ê°€ë¦¼í† "], c: 0 },
    { q: "ì„ì§„ì™œë€ ë•Œ ê±°ë¶ì„ ì„ ë§Œë“¤ì–´ ì¼ë³¸êµ°ì„ ë¬¼ë¦¬ì¹œ ì¥êµ°ì€?", a: ["ì´ìˆœì‹ ", "ê¶Œìœ¨", "ê¹€ì‹œë¯¼", "ê³½ì¬ìš°"], c: 0 },
    { q: "ë³‘ìí˜¸ë€ ë•Œ ì¸ì¡°ê°€ í”¼ì‹ í•˜ì—¬ í•­ì „í–ˆë˜ ì‚°ì„±ì€?", a: ["ë‚¨í•œì‚°ì„±", "ë¶í•œì‚°ì„±", "ìˆ˜ì›í™”ì„±", "í–‰ì£¼ì‚°ì„±"], c: 0 },
    { q: "ì¡°ì„  í›„ê¸° ì˜ì¡°ê°€ ë‹¹ìŸì„ ì—†ì• ê¸° ìœ„í•´ ì‹¤ì‹œí•œ ì •ì±…ì€?", a: ["íƒ•í‰ì±…", "ê³¨í’ˆì œ", "í™”ë‘ë„", "í˜¸íŒ¨ë²•"], c: 0 },
    { q: "ì •ì¡°ê°€ ì„¸ìš´ ê³„íš ë„ì‹œë¡œ, ìœ ë„¤ìŠ¤ì½” ì„¸ê³„ ìœ ì‚°ì¸ ê³³ì€?", a: ["ìˆ˜ì› í™”ì„±", "ê²½ë³µê¶", "ì°½ë•ê¶", "ë¶ˆêµ­ì‚¬"], c: 0 },
    { q: "ìˆ˜ì› í™”ì„± ê±´ì„¤ì— ì‚¬ìš©ëœ ì •ì•½ìš©ì˜ ë°œëª…í’ˆì€?", a: ["ê±°ì¤‘ê¸°", "ì¸¡ìš°ê¸°", "ìê²©ë£¨", "í•´ì‹œê³„"], c: 0 },
    { q: "ì¡°ì„  ì „ì²´ì˜ ì§€ë„ë¥¼ ì§ì ‘ ë°œë¡œ ë›°ì–´ ë§Œë“  ê¹€ì •í˜¸ì˜ ì§€ë„ëŠ”?", a: ["ëŒ€ë™ì—¬ì§€ë„", "í˜¼ì¼ê°•ë¦¬ë„", "ì²œí•˜ë„", "ë™êµ­ì§€ë„"], c: 0 },
    { q: "í¥ì„ ëŒ€ì›êµ°ì´ ì„œì–‘ê³¼ì˜ í†µìƒì„ ê±°ë¶€í•˜ë©° ì„¸ìš´ ë¹„ì„ì€?", a: ["ì²™í™”ë¹„", "ê´‘ê°œí† ëŒ€ì™•ë¦‰ë¹„", "ì§„í¥ì™•ìˆœìˆ˜ë¹„", "ì¤‘ì›ê³ êµ¬ë ¤ë¹„"], c: 0 },
    { q: "ìš°ë¦¬ë‚˜ë¼ê°€ ë§ºì€ ìµœì´ˆì˜ ê·¼ëŒ€ì  ì¡°ì•½ì€?", a: ["ê°•í™”ë„ ì¡°ì•½", "ì„ì‚¬ëŠ‘ì•½", "í•œì¼í•©ë³‘", "í…ì§„ ì¡°ì•½"], c: 0 },
    { q: "ê¹€ì˜¥ê·  ë“±ì´ ìš°ì •ì´êµ­ ì¶•í•˜ì—°ì„ ê¸°íšŒë¡œ ì¼ìœ¼í‚¨ ì‚¬ê±´ì€?", a: ["ê°‘ì‹ ì •ë³€", "ì„ì˜¤êµ°ë€", "ë™í•™ë†ë¯¼ìš´ë™", "ì„ë¯¸ì‚¬ë³€"], c: 0 },
    { q: "ë…¹ë‘ ì¥êµ° ì „ë´‰ì¤€ì´ ì´ëŒì—ˆë˜ ë†ë¯¼ ìš´ë™ì€?", a: ["ë™í•™ ë†ë¯¼ ìš´ë™", "3.1 ìš´ë™", "ë¬¼ì‚° ì¥ë ¤ ìš´ë™", "êµ­ì±„ ë³´ìƒ ìš´ë™"], c: 0 },
    { q: "ì¼ë³¸ ìê°ë“¤ì´ ê²½ë³µê¶ì— ì¹¨ì…í•´ ëª…ì„±í™©í›„ë¥¼ ì‹œí•´í•œ ì‚¬ê±´ì€?", a: ["ì„ë¯¸ì‚¬ë³€", "ì„ì˜¤êµ°ë€", "ê°‘ì‹ ì •ë³€", "ì•„ê´€íŒŒì²œ"], c: 0 },
    { q: "ê³ ì¢…ì´ ì„ í¬í•œ ìš°ë¦¬ë‚˜ë¼ì˜ ì˜› êµ­í˜¸ëŠ”?", a: ["ëŒ€í•œ ì œêµ­", "ê³ ë ¤", "ì‹ ë¼", "ë°±ì œ"], c: 0 },
    { q: "ì¼ë³¸ì´ ëŒ€í•œ ì œêµ­ì˜ ì™¸êµê¶Œì„ ë¹¼ì•—ì€ ê°•ì œ ì¡°ì•½ì€?", a: ["ì„ì‚¬ëŠ‘ì•½", "ì •ë¯¸ 7ì¡°ì•½", "í•œì¼ ì˜ì •ì„œ", "ê°•í™”ë„ ì¡°ì•½"], c: 0 },
    { q: "í•˜ì–¼ë¹ˆ ì—­ì—ì„œ ì´í†  íˆë¡œë¶€ë¯¸ë¥¼ ì‚¬ì‚´í•œ ë…ë¦½ìš´ë™ê°€ëŠ”?", a: ["ì•ˆì¤‘ê·¼", "ìœ¤ë´‰ê¸¸", "ì´ë´‰ì°½", "ê¹€êµ¬"], c: 0 },
    { q: "1919ë…„ 3ì›” 1ì¼ ì‹œì‘ëœ ì „êµ­ì ì¸ ë§Œì„¸ ìš´ë™ì€?", a: ["3.1 ìš´ë™", "6.10 ë§Œì„¸ ìš´ë™", "ê´‘ì£¼ í•™ìƒ í•­ì¼ ìš´ë™", "ë¬¼ì‚° ì¥ë ¤ ìš´ë™"], c: 0 },
    { q: "3.1 ìš´ë™ì˜ ê²°ê³¼ë¡œ ìƒí•˜ì´ì— ìˆ˜ë¦½ëœ ì •ë¶€ëŠ”?", a: ["ëŒ€í•œë¯¼êµ­ ì„ì‹œ ì •ë¶€", "ì¡°ì„  ì´ë…ë¶€", "í†µê°ë¶€", "ë‚¨ì¡°ì„  ê³¼ë„ ì •ë¶€"], c: 0 },
    { q: "í™ë²”ë„ ì¥êµ°ì´ ì¼ë³¸êµ°ì„ í¬ê²Œ ë¬´ì°Œë¥¸ ì „íˆ¬ëŠ”?", a: ["ë´‰ì˜¤ë™ ì „íˆ¬", "ì²­ì‚°ë¦¬ ëŒ€ì²©", "ëŒ€ì „ìë ¹ ì „íˆ¬", "ìŒì„±ë³´ ì „íˆ¬"], c: 0 },
    { q: "ê¹€ì¢Œì§„ ì¥êµ°ì´ ì´ëˆ ë¶ë¡œ êµ°ì •ì„œêµ°ì´ ìŠ¹ë¦¬í•œ ì „íˆ¬ëŠ”?", a: ["ì²­ì‚°ë¦¬ ëŒ€ì²©", "ë´‰ì˜¤ë™ ì „íˆ¬", "ì‚´ìˆ˜ ëŒ€ì²©", "í–‰ì£¼ ëŒ€ì²©"], c: 0 },
    { q: "ìƒí•˜ì´ í›™ì»¤ìš° ê³µì›ì—ì„œ ë„ì‹œë½ í­íƒ„ì„ ë˜ì§„ ì˜ê±° í™œë™ê°€ëŠ”?", a: ["ìœ¤ë´‰ê¸¸", "ì´ë´‰ì°½", "ë‚˜ì„ì£¼", "ê¹€ìƒì˜¥"], c: 0 },
    { q: "ì¼ì œ ê°•ì ê¸° ë•Œ ìš°ë¦¬ë§ì„ ì§€í‚¤ê¸° ìœ„í•´ í™œë™í•œ ë‹¨ì²´ëŠ”?", a: ["ì¡°ì„ ì–´ í•™íšŒ", "ì‹ ê°„íšŒ", "ê·¼ìš°íšŒ", "ì˜ì—´ë‹¨"], c: 0 },
    { q: "'ì„œì‹œ', 'ë³„ í—¤ëŠ” ë°¤' ë“±ì„ ì“´ ë¯¼ì¡± ì‹œì¸ì€?", a: ["ìœ¤ë™ì£¼", "ì´ìœ¡ì‚¬", "í•œìš©ìš´", "ì‹¬í›ˆ"], c: 0 },
    { q: "ìš°ë¦¬ë‚˜ë¼ê°€ ì¼ë³¸ìœ¼ë¡œë¶€í„° ê´‘ë³µì„ ë§ì´í•œ ë‚ ì§œëŠ”?", a: ["1945ë…„ 8ì›” 15ì¼", "1919ë…„ 3ì›” 1ì¼", "1950ë…„ 6ì›” 25ì¼", "1948ë…„ 8ì›” 15ì¼"], c: 0 },
    { q: "ìš°ë¦¬ë‚˜ë¼ ìµœì´ˆì˜ ë¯¼ì£¼ì ì¸ ì„ ê±°ì¸ 5.10 ì´ì„ ê±°ê°€ ì‹¤ì‹œëœ í•´ëŠ”?", a: ["1948ë…„", "1945ë…„", "1950ë…„", "1960ë…„"], c: 0 },
    { q: "6.25 ì „ìŸì´ ë°œë°œí•œ ì—°ë„ëŠ”?", a: ["1950ë…„", "1945ë…„", "1948ë…„", "1953ë…„"], c: 0 },
    { q: "6.25 ì „ìŸì˜ ì „ì„¸ë¥¼ ë’¤ì§‘ì€ ë§¥ì•„ë” ì¥êµ°ì˜ ì‘ì „ì€?", a: ["ì¸ì²œ ìƒë¥™ ì‘ì „", "ë‚™ë™ê°• ë°©ì–´ ì‘ì „", "í¥ë‚¨ ì² ìˆ˜ ì‘ì „", "ë‹¤ë¶€ë™ ì „íˆ¬"], c: 0 },
    { q: "3.15 ë¶€ì • ì„ ê±°ì— í•­ê±°í•˜ì—¬ ì¼ì–´ë‚œ ë¯¼ì£¼ì£¼ì˜ í˜ëª…ì€?", a: ["4.19 í˜ëª…", "5.18 ë¯¼ì£¼í™” ìš´ë™", "6ì›” ë¯¼ì£¼ í•­ìŸ", "ë¶€ë§ˆ í•­ìŸ"], c: 0 },
    { q: "1980ë…„ ê´‘ì£¼ì—ì„œ ì¼ì–´ë‚œ ë¯¼ì£¼í™” ìš´ë™ì€?", a: ["5.18 ë¯¼ì£¼í™” ìš´ë™", "4.19 í˜ëª…", "6.3 ì‹œìœ„", "10.26 ì‚¬íƒœ"], c: 0 },
    { q: "ëŒ€í†µë ¹ì„ êµ­ë¯¼ì´ ì§ì ‘ ë½‘ëŠ” ì§ì„ ì œë¥¼ ì´ëŒì–´ë‚¸ í•­ìŸì€?", a: ["6ì›” ë¯¼ì£¼ í•­ìŸ", "3.1 ìš´ë™", "4.19 í˜ëª…", "5.18 ë¯¼ì£¼í™” ìš´ë™"], c: 0 },
    { q: "1997ë…„ ì™¸í™˜ ìœ„ê¸°(IMF)ë¥¼ ê·¹ë³µí•˜ê¸° ìœ„í•´ êµ­ë¯¼ë“¤ì´ ë²Œì¸ ìš´ë™ì€?", a: ["ê¸ˆ ëª¨ìœ¼ê¸° ìš´ë™", "ë¬¼ì‚° ì¥ë ¤ ìš´ë™", "êµ­ì±„ ë³´ìƒ ìš´ë™", "ì•„ë‚˜ë°”ë‹¤ ìš´ë™"], c: 0 },
    { q: "2002ë…„ í•œì¼ ì›”ë“œì»µ ë•Œ ìš°ë¦¬ë‚˜ë¼ì˜ ì„±ì ì€?", a: ["4ê°•", "16ê°•", "8ê°•", "ìš°ìŠ¹"], c: 0 },
    { q: "ìš°ë¦¬ë‚˜ë¼ ë™ìª½ ëì— ìˆëŠ” ì„¬ìœ¼ë¡œ, ì²œì—°ê¸°ë…ë¬¼ ì œ336í˜¸ì¸ ê³³ì€?", a: ["ë…ë„", "ìš¸ë¦‰ë„", "ì œì£¼ë„", "ë§ˆë¼ë„"], c: 0 }
];

const CONFIG = {
    FPS: 60, TILE_SIZE: 40, PATH_WIDTH: 30, WAVE_DELAY: 2000, MAX_WAVE: 15, EVOLUTION_KILLS: 25
};

const TOWERS = {
    basic: { name: "ê¸°ë³¸", type: 'basic', cost: 50, range: 120, damage: 15, cooldown: 40, color: '#38bdf8', key:'1' },
    rapid: { name: "ì†ì‚¬", type: 'rapid', cost: 120, range: 100, damage: 5, cooldown: 8, color: '#facc15', key:'2' },
    ice: { name: "ì–¼ìŒ", type: 'ice', cost: 150, range: 130, damage: 5, cooldown: 45, color: '#60a5fa', key:'3' },
    flame: { name: "í™”ì—¼", type: 'flame', cost: 250, range: 80, damage: 2, cooldown: 3, color: '#f97316', key:'4' },
    sniper: { name: "ì €ê²©", type: 'sniper', cost: 200, range: 250, damage: 80, cooldown: 120, color: '#22c55e', key:'5' },
    splash: { name: "ê´‘ì—­", type: 'splash', cost: 300, range: 150, damage: 40, cooldown: 90, color: '#f43f5e', key:'6' },
    tesla: { name: "í…ŒìŠ¬ë¼", type: 'tesla', cost: 350, range: 140, damage: 25, cooldown: 50, color: '#a855f7', key:'7' },
    laser: { name: "ë ˆì´ì €", type: 'laser', cost: 400, range: 160, damage: 2, cooldown: 0, color: '#d946ef', key:'8' },
    railgun: { name: "ë ˆì¼ê±´", type: 'railgun', cost: 450, range: 300, damage: 150, cooldown: 120, color: '#06b6d4', key:'9' },
    nuke: { name: "í•µí­íƒ„", type: 'nuke', cost: 800, range: 200, damage: 500, cooldown: 300, color: '#be123c', key:'0' },
    
    poison: { name: "ë…", type: 'poison', cost: 220, range: 120, damage: 5, cooldown: 40, color: '#4ade80', key:'Q' },
    multi: { name: "ë©€í‹°", type: 'multi', cost: 320, range: 140, damage: 12, cooldown: 50, color: '#e879f9', key:'W' },
    minigun: { name: "ë¯¸ë‹ˆê±´", type: 'minigun', cost: 500, range: 150, damage: 4, cooldown: 15, color: '#94a3b8', key:'E' },
    buff: { name: "ë²„í”„", type: 'buff', cost: 400, range: 100, damage: 0, cooldown: 0, color: '#fbbf24', key:'R' }, 
    blackhole: { name: "ë¸”ë™í™€", type: 'blackhole', cost: 600, range: 160, damage: 10, cooldown: 180, color: '#1e293b', key:'T' },
    
    meteor: { name: "ë©”í…Œì˜¤", type: 'meteor', cost: 700, range: 200, damage: 200, cooldown: 150, color: '#b91c1c', key:'Y' },
    curse: { name: "ì €ì£¼", type: 'curse', cost: 350, range: 130, damage: 5, cooldown: 40, color: '#581c87', key:'U' },
    gold: { name: "í™©ê¸ˆ", type: 'gold', cost: 450, range: 100, damage: 10, cooldown: 30, color: '#fcd34d', key:'I' },
    time: { name: "ì‹œê°„", type: 'time', cost: 550, range: 150, damage: 0, cooldown: 120, color: '#2dd4bf', key:'O' },

    wind: { name: "ë°”ëŒ", type: 'wind', cost: 250, range: 130, damage: 15, cooldown: 60, color: '#bae6fd', key:'A' },
    mortar: { name: "ë°•ê²©í¬", type: 'mortar', cost: 380, range: 250, minRange: 80, damage: 60, cooldown: 100, color: '#713f12', key:'S' },
    shock: { name: "ì „ê¸°ì¥", type: 'shock', cost: 480, range: 100, damage: 30, cooldown: 70, color: '#fde047', key:'D' },
    execute: { name: "ì²˜í˜•", type: 'execute', cost: 520, range: 140, damage: 40, cooldown: 50, color: '#991b1b', key:'F' },
    prism: { name: "í”„ë¦¬ì¦˜", type: 'prism', cost: 420, range: 150, damage: 20, cooldown: 45, color: '#fff', key:'G' },
    soul: { name: "ì˜í˜¼", type: 'soul', cost: 600, range: 140, damage: 10, cooldown: 30, color: '#312e81', key:'H' },
    speed: { name: "ê°€ì†", type: 'speed', cost: 450, range: 100, damage: 0, cooldown: 0, color: '#ec4899', key:'J' },

    healer: { name: "ìˆ˜ë¦¬", type: 'healer', cost: 300, range: 150, damage: -30, cooldown: 60, color: '#10b981', key:'-' },
};

const ENEMIES = [
    { name: "Orb", hp: 80, speed: 1.5, reward: 8, color: '#a855f7', radius: 10 },
    { name: "Fast", hp: 60, speed: 3.2, reward: 10, color: '#f472b6', radius: 8 },
    { name: "Tank", hp: 400, speed: 0.8, reward: 20, color: '#ef4444', radius: 14 },
    { name: "Boss", hp: 2000, speed: 0.5, reward: 100, color: '#ffffff', radius: 24 },
    { name: "Breaker", hp: 300, speed: 1.0, reward: 30, color: '#f97316', radius: 16, isBreaker: true, damage: 1 }
];

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.lives = 20; this.money = 300; this.difficultyMultiplier = 1.0;
        this.stage = 1; this.maxStages = 3; this.wave = 1;
        this.isPlaying = false; this.isGameOver = false; this.isPaused = false; 
        
        this.towers = []; this.enemies = []; this.projectiles = []; this.particles = []; this.mapPoints = [];
        this.selectedTowerType = null;
        this.lastTime = 0; this.waveTimer = 0; this.enemiesToSpawn = []; this.spawnTimer = 0;
        this.mouse = { x: 0, y: 0 }; this.hoverTile = { x: 0, y: 0 }; this.pendingBuild = null;
        this.freeBuild = false; 
        this.particles = [];
        
        // ë°°ì† ê´€ë ¨
        this.gameSpeed = 1;
        this.speedUnlocked = false;

        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.setupInput();
        this.setupUI();
        
        document.getElementById('btn-easy').onclick = () => this.startGame('easy');
        document.getElementById('btn-normal').onclick = () => this.startGame('normal');
        document.getElementById('btn-hard').onclick = () => this.startGame('hard');
        document.getElementById('btn-next-stage').onclick = () => this.nextStage();
        document.getElementById('speed-btn').onclick = () => this.toggleSpeed();
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        CONFIG.TILE_SIZE = Math.max(40, Math.floor(Math.min(this.canvas.width, this.canvas.height) / 20)); 
        this.generateMap(this.stage);
    }

    generateMap(stage) {
        const w = this.canvas.width, h = this.canvas.height;
        this.mapPoints = [];
        if (stage === 1) this.mapPoints = [{x:0,y:h*0.2}, {x:w*0.8,y:h*0.2}, {x:w*0.8,y:h*0.5}, {x:w*0.2,y:h*0.5}, {x:w*0.2,y:h*0.8}, {x:w,y:h*0.8}];
        else if (stage === 2) this.mapPoints = [{x:0,y:h*0.1}, {x:w*0.9,y:h*0.1}, {x:w*0.9,y:h*0.3}, {x:w*0.1,y:h*0.3}, {x:w*0.1,y:h*0.5}, {x:w*0.9,y:h*0.5}, {x:w*0.9,y:h*0.7}, {x:w*0.1,y:h*0.7}, {x:w*0.1,y:h*0.9}, {x:w,y:h*0.9}];
        else this.mapPoints = [{x:0,y:h*0.1}, {x:w*0.9,y:h*0.1}, {x:w*0.9,y:h*0.9}, {x:w*0.1,y:h*0.9}, {x:w*0.1,y:h*0.3}, {x:w*0.7,y:h*0.3}, {x:w*0.7,y:h*0.7}, {x:w*0.3,y:h*0.7}, {x:w*0.3,y:h*0.5}, {x:w*0.5,y:h*0.5}];
    }

    setupInput() {
        const updateMouse = (e) => {
            const rect = this.canvas.getBoundingClientRect();
            this.mouse.x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            this.mouse.y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            this.hoverTile.x = Math.floor(this.mouse.x / CONFIG.TILE_SIZE) * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
            this.hoverTile.y = Math.floor(this.mouse.y / CONFIG.TILE_SIZE) * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        };
        this.canvas.addEventListener('mousemove', updateMouse);
        this.canvas.addEventListener('touchmove', updateMouse, {passive: false});
        this.canvas.addEventListener('mousedown', () => {
            if (!this.isPlaying || this.isGameOver || this.isPaused) return;
            if (this.selectedTowerType === 'sell') this.trySellTower();
            else this.tryBuildTower();
        });
        window.addEventListener('keydown', (e) => {
            if (this.isPaused) return;
            if (this.freeBuild) return; // ê°€ì±  ëª¨ë“œì¼ ë• ë³€ê²½ ë¶ˆê°€ (ê°•ì œ ì„¤ì¹˜)
            const key = e.key.toUpperCase();
            if (key === '=' || key === '+') { this.selectTower('sell'); return; }
            for (const type in TOWERS) {
                if (TOWERS[type].key === key) { this.selectTower(type); return; }
            }
        });
    }

    setupUI() {
        const bottomBar = document.querySelector('.bottom-bar');
        bottomBar.innerHTML = ''; 
        
        const gachaBtn = document.createElement('div');
        gachaBtn.className = 'tower-btn btn-gacha';
        gachaBtn.innerHTML = `<div class="tower-preview" style="background:transparent; font-size:16px;">ğŸ²</div><div class="tower-info"><div class="tower-name">ë½‘ê¸°</div><div class="tower-cost">300G</div></div>`;
        gachaBtn.onclick = () => this.tryGacha();
        bottomBar.appendChild(gachaBtn);

        const order = ['basic','rapid','ice','flame','sniper','splash','tesla','laser','railgun','nuke',
                       'poison','multi','minigun','buff','blackhole',
                       'meteor','curse','gold','time',
                       'wind','mortar','shock','execute','prism','soul','speed', 'healer'];
        order.forEach((type) => {
            const t = TOWERS[type];
            const btn = document.createElement('div');
            btn.className = 'tower-btn';
            btn.id = `btn-${type}`;
            btn.innerHTML = `<span class="shortcut-key">${t.key}</span><div class="tower-preview t-${type}"></div><div class="tower-info"><div class="tower-name">${t.name}</div><div class="tower-cost">${t.cost}</div></div>`;
            btn.onclick = () => { if(!this.freeBuild) this.selectTower(type); };
            bottomBar.appendChild(btn);
        });
        const sellBtn = document.createElement('div');
        sellBtn.className = 'tower-btn btn-sell';
        sellBtn.id = `btn-sell`;
        sellBtn.innerHTML = `<span class="shortcut-key">=</span><div class="tower-preview" style="background:#ef4444;">ğŸ—‘ï¸</div><div class="tower-info"><div class="tower-name">íŒë§¤</div><div class="tower-cost">70%</div></div>`;
        sellBtn.onclick = () => { if(!this.freeBuild) this.selectTower('sell'); };
        bottomBar.appendChild(sellBtn);
    }

    toggleSpeed() {
        if (this.gameSpeed === 2) {
            this.gameSpeed = 1;
            this.updateStats();
        } else {
            // 1ë°°ì† -> 2ë°°ì† ì‹œë„
            if (this.speedUnlocked) {
                this.gameSpeed = 2;
                this.updateStats();
            } else {
                this.triggerQuiz(null, null, 'UNLOCK_SPEED');
            }
        }
    }

    tryGacha() {
        if (this.money < 300) {
            this.showFloatingText(this.canvas.width/2, this.canvas.height/2, "ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!", "#ff4444");
            return;
        }
        if (this.freeBuild) return; 

        this.money -= 300;
        this.updateStats();

        const types = Object.keys(TOWERS).filter(k => k !== 'healer');
        const weights = {};
        let totalWeight = 0;

        types.forEach(type => {
            const cost = TOWERS[type].cost;
            let w = 0;
            if (cost < 100) w = 200;       
            else if (cost < 300) w = 100;  
            else if (cost < 500) w = 40;   
            else if (cost < 700) w = 10;   
            else w = 3;                    
            weights[type] = w;
            totalWeight += w;
        });

        let rnd = Math.random() * totalWeight;
        let selected = 'basic';
        for (const type of types) {
            if (rnd < weights[type]) { selected = type; break; }
            rnd -= weights[type];
        }

        this.selectTower(selected);
        this.freeBuild = true; 
        this.showFloatingText(this.canvas.width/2, this.canvas.height/2, `íšë“: ${TOWERS[selected].name}!`, TOWERS[selected].color);
        for(let i=0; i<30; i++) this.createParticles(this.canvas.width/2, this.canvas.height/2, 1, TOWERS[selected].color);
    }

    showFloatingText(x, y, text, color) {
        this.particles.push({
            x: x, y: y, text: text, color: color, life: 60, vy: -1, update: function() { this.y += this.vy; this.life--; },
            draw: function(ctx) { 
                ctx.globalAlpha = Math.max(0, this.life/60); 
                ctx.font = "bold 30px Gamja Flower"; 
                ctx.fillStyle = this.color; 
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText(this.text, this.x - 50, this.y);
                ctx.fillText(this.text, this.x - 50, this.y); 
                ctx.globalAlpha = 1;
            }
        });
    }

    selectTower(type) {
        this.selectedTowerType = type;
        document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
        const btn = document.getElementById(`btn-${type}`);
        if (btn) btn.classList.add('selected');
    }

    trySellTower() {
        let clickedTowerIndex = -1;
        for (let i = 0; i < this.towers.length; i++) {
            const t = this.towers[i];
            if (Math.hypot(t.x - this.mouse.x, t.y - this.mouse.y) < CONFIG.TILE_SIZE * 0.8) { clickedTowerIndex = i; break; }
        }
        if (clickedTowerIndex !== -1) {
            const t = this.towers[clickedTowerIndex];
            this.money += Math.floor(TOWERS[t.type].cost * 0.7);
            this.createParticles(t.x, t.y, 15, '#eab308');
            this.towers.splice(clickedTowerIndex, 1);
            this.updateStats();
        }
    }

    tryBuildTower() {
        if (!this.selectedTowerType || this.selectedTowerType === 'sell') return;
        const towerConfig = TOWERS[this.selectedTowerType];
        if (!this.freeBuild && this.money < towerConfig.cost) return;
        if (!this.isValidBuildPosition(this.hoverTile.x, this.hoverTile.y)) return;
        this.triggerQuiz(this.hoverTile.x, this.hoverTile.y, this.selectedTowerType);
    }

    triggerQuiz(x, y, type) {
        this.isPaused = true;
        this.pendingBuild = { x, y, type };
        const quizData = HISTORY_QUIZ[Math.floor(Math.random() * HISTORY_QUIZ.length)];
        const modal = document.getElementById('quiz-modal');
        document.getElementById('quiz-question').innerText = quizData.q;
        const optionsDiv = document.getElementById('quiz-options');
        optionsDiv.innerHTML = '';
        const opts = quizData.a.map((txt, idx) => ({ txt, idx }));
        opts.sort(() => Math.random() - 0.5);
        opts.forEach(opt => {
            const btn = document.createElement('button');
            btn.className = 'quiz-btn';
            btn.innerText = opt.txt;
            btn.onclick = () => {
                if (btn.classList.contains('correct') || btn.classList.contains('wrong')) return;
                if (opt.idx === quizData.c) {
                    btn.classList.add('correct'); setTimeout(() => this.finishQuiz(true), 400);
                } else {
                    btn.classList.add('wrong'); setTimeout(() => this.finishQuiz(false), 800);
                }
            };
            optionsDiv.appendChild(btn);
        });
        modal.style.display = 'flex';
    }

    finishQuiz(success) {
        document.getElementById('quiz-modal').style.display = 'none';
        this.isPaused = false;
        
        if (success && this.pendingBuild) {
            const { x, y, type } = this.pendingBuild;
            
            if (type === 'UNLOCK_SPEED') {
                this.speedUnlocked = true;
                this.gameSpeed = 2;
                this.updateStats();
                this.showFloatingText(this.canvas.width/2, this.canvas.height/2, "2ë°°ì† í•´ê¸ˆ ì™„ë£Œ!", "#eab308");
            } else {
                const cost = this.freeBuild ? 0 : TOWERS[type].cost; 
                if (this.money >= cost) {
                    this.money -= cost;
                    this.towers.push(new Tower(x, y, type));
                    this.createParticles(x, y, 10, TOWERS[type].color);
                    this.updateStats();
                    this.freeBuild = false; 
                    this.selectTower(null); 
                }
            }
        }
        this.pendingBuild = null;
    }

    isValidBuildPosition(x, y) {
        for (let t of this.towers) { if (Math.hypot(t.x - x, t.y - y) < CONFIG.TILE_SIZE * 0.8) return false; }
        for (let i = 0; i < this.mapPoints.length - 1; i++) {
            if (this.distToSegment(x, y, this.mapPoints[i].x, this.mapPoints[i].y, this.mapPoints[i+1].x, this.mapPoints[i+1].y) < CONFIG.TILE_SIZE/2 + CONFIG.PATH_WIDTH/2) return false;
        }
        return true;
    }

    distToSegment(x, y, x1, y1, x2, y2) {
        const A = x - x1, B = y - y1, C = x2 - x1, D = y2 - y1;
        const dot = A * C + B * D, lenSq = C * C + D * D;
        let param = -1; if (lenSq !== 0) param = dot / lenSq;
        let xx, yy; if (param < 0) { xx = x1; yy = y1; } else if (param > 1) { xx = x2; yy = y2; } else { xx = x1 + param * C; yy = y1 + param * D; }
        const dx = x - xx, dy = y - yy; return Math.sqrt(dx * dx + dy * dy);
    }

    startGame(difficulty) {
        if (difficulty === 'easy') { this.money = 400; this.lives = 30; this.difficultyMultiplier = 0.7; }
        else if (difficulty === 'normal') { this.money = 300; this.lives = 20; this.difficultyMultiplier = 1.0; }
        else { this.money = 200; this.lives = 10; this.difficultyMultiplier = 1.5; }
        document.getElementById('start-modal').style.display = 'none';
        this.isPlaying = true;
        this.updateStats();
        this.startWave();
        this.gameLoop();
    }
    
    nextStage() {
        this.stage++;
        if (this.stage > this.maxStages) {
            document.getElementById('stage-modal').style.display = 'none';
            document.getElementById('victory-modal').style.display = 'flex';
            this.isPlaying = false; return;
        }
        this.wave = 1; this.towers = []; this.enemies = []; this.projectiles = []; this.money += 300;
        this.resize();
        document.getElementById('stage-modal').style.display = 'none';
        this.startWave(); this.isPaused = false; this.updateStats();
    }

    startWave() {
        this.enemiesToSpawn = [];
        const count = 9 + this.wave;
        let enemyType = 0;
        if (this.wave % 10 === 0) enemyType = 3; 
        else if (this.wave % 5 === 0) enemyType = 4; 
        else if (this.wave % 4 === 0) enemyType = 2; 
        else if (this.wave % 2 === 0) enemyType = 1; 
        for (let i = 0; i < count; i++) this.enemiesToSpawn.push(enemyType);
        if (this.wave > 3) {
             if (this.wave % 3 === 0) this.enemiesToSpawn.push(4);
             for(let i=0; i< Math.floor(this.wave/2); i++) this.enemiesToSpawn.push(0);
        }
        this.updateStats();
    }

    gameOver() {
        this.isGameOver = true; this.isPlaying = false;
        document.getElementById('gameover-desc').innerText = `ìŠ¤í…Œì´ì§€ ${this.stage} - ì›¨ì´ë¸Œ ${this.wave}`;
        document.getElementById('gameover-modal').style.display = 'flex';
    }

    updateStats() {
        document.getElementById('lives-display').innerText = this.lives;
        document.getElementById('money-display').innerText = Math.floor(this.money);
        document.getElementById('wave-display').innerText = `${this.wave}/${CONFIG.MAX_WAVE}`;
        document.getElementById('stage-display').innerText = this.stage;
        
        // ë°°ì† ë²„íŠ¼ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        const speedBtn = document.getElementById('speed-btn');
        speedBtn.innerText = this.gameSpeed === 1 ? "â–¶" : "â©";
        if(this.gameSpeed === 2) speedBtn.classList.add('active');
        else speedBtn.classList.remove('active');

        Object.keys(TOWERS).forEach(type => {
            const btn = document.getElementById(`btn-${type}`);
            if (btn) {
                if (!this.freeBuild && this.money < TOWERS[type].cost) btn.classList.add('disabled');
                else btn.classList.remove('disabled');
            }
        });
    }

    createParticles(x, y, count, color) {
        for (let i = 0; i < count; i++) this.particles.push(new Particle(x, y, color));
    }

    update() {
        if (!this.isPlaying || this.isPaused) return;

        if (this.enemiesToSpawn.length > 0) {
            this.spawnTimer++;
            if (this.spawnTimer > 30) {
                const typeIdx = this.enemiesToSpawn.shift();
                this.enemies.push(new Enemy(this.mapPoints, typeIdx, this));
                this.spawnTimer = 0;
            }
        } else if (this.enemies.length === 0 && this.waveTimer === 0) {
            if (this.wave >= CONFIG.MAX_WAVE) {
                this.isPaused = true; document.getElementById('stage-modal').style.display = 'flex'; return;
            }
            this.waveTimer = 1;
        }

        if (this.waveTimer > 0) {
            this.waveTimer++;
            if (this.waveTimer > 180) {
                this.wave++; this.money += 100 + (this.wave * 25);
                this.startWave(); this.waveTimer = 0;
            }
        }

        this.towers.forEach(t => t.resetBuffs());
        this.towers.forEach(t => {
            if (t.type === 'buff') t.applyBuff(this.towers, 'damage', 1.5);
            if (t.type === 'speed') t.applyBuff(this.towers, 'speed', 0.7); 
        });

        for (let i = this.towers.length - 1; i >= 0; i--) {
            const t = this.towers[i];
            if (t.hp <= 0) {
                this.createParticles(t.x, t.y, 20, '#ffffff'); this.towers.splice(i, 1);
            } else {
                t.update(this.enemies, this);
            }
        }

        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const p = this.projectiles[i];
            p.update();
            let hit = false;
            if (p.hasReachedTarget()) {
                hit = true;
                if (p.type === 'splash' || p.type === 'nuke' || p.type === 'meteor' || p.type === 'mortar') {
                    let range = 70;
                    if (p.type === 'nuke') range = 150;
                    if (p.type === 'meteor') range = 100;
                    if (p.type === 'mortar') range = 80;
                    
                    const color = p.type === 'nuke' ? '#be123c' : (p.type === 'meteor' ? '#b91c1c' : (p.type === 'mortar' ? '#713f12' : '#f43f5e'));
                    this.createParticles(p.x, p.y, 20, color);
                    this.enemies.forEach(enemy => { if (Math.hypot(enemy.x - p.x, enemy.y - p.y) < range) p.dealDamage(enemy); });
                } else if (p.type === 'ice') {
                    if (p.target && p.target.hp > 0) { p.dealDamage(p.target); p.target.freeze(60); this.createParticles(p.x, p.y, 5, '#60a5fa'); }
                } else if (p.type === 'poison') {
                    if (p.target && p.target.hp > 0) { p.dealDamage(p.target); p.target.poison(180, p.damage * 0.2); this.createParticles(p.x, p.y, 5, '#4ade80'); }
                } else if (p.type === 'curse') {
                    if (p.target && p.target.hp > 0) { p.dealDamage(p.target); p.target.curse(180); this.createParticles(p.x, p.y, 5, '#581c87'); }
                } else if (p.type === 'blackhole') {
                    const range = 100; this.createParticles(p.x, p.y, 20, '#1e293b');
                    this.enemies.forEach(enemy => { if (Math.hypot(enemy.x - p.x, enemy.y - p.y) < range) { p.dealDamage(enemy); enemy.pullBack(30); } });
                } else if (p.type === 'gold') {
                    if (p.target && p.target.hp > 0) { p.target.goldBonus = 5; p.dealDamage(p.target); this.createParticles(p.x, p.y, 5, '#fcd34d'); }
                } else if (p.type === 'wind') {
                    if (p.target && p.target.hp > 0) { p.dealDamage(p.target); p.target.knockback(15); this.createParticles(p.x, p.y, 5, '#bae6fd'); }
                } else if (p.type === 'prism') {
                    if (p.target && p.target.hp > 0) {
                        p.dealDamage(p.target);
                        const rand = Math.random();
                        if (rand < 0.33) p.target.freeze(40);
                        else if (rand < 0.66) p.target.poison(100, 2);
                        else p.target.curse(100);
                        this.createParticles(p.x, p.y, 5, '#fff');
                    }
                } else {
                    if (p.target && p.target.hp > 0) { p.dealDamage(p.target); this.createParticles(p.x, p.y, 5, '#ffffff'); }
                }
            }
            if (hit || p.life <= 0) this.projectiles.splice(i, 1);
        }

        for (let i = this.enemies.length - 1; i >= 0; i--) {
            const enemy = this.enemies[i];
            enemy.update(this);
            if (enemy.finished) {
                this.lives--; this.updateStats(); this.enemies.splice(i, 1);
                if (this.lives <= 0) this.gameOver();
            } else if (enemy.hp <= 0) {
                this.money += enemy.reward;
                if(enemy.goldBonus > 0) { this.money += enemy.goldBonus; this.createParticles(enemy.x, enemy.y, 5, '#fcd34d'); }
                this.updateStats();
                this.createParticles(enemy.x, enemy.y, 10, enemy.color);
                this.enemies.splice(i, 1);
            }
        }
        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update();
            if(this.particles[i].draw) {} 
            else if (this.particles[i].life <= 0) this.particles.splice(i, 1);
        }
        for (let i = this.particles.length - 1; i >= 0; i--) {
             if(this.particles[i].draw && this.particles[i].life <= 0) this.particles.splice(i, 1);
        }
    }

    draw() {
        this.ctx.fillStyle = '#0f172a'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.beginPath(); this.ctx.lineWidth = CONFIG.PATH_WIDTH; this.ctx.lineCap = 'round'; this.ctx.lineJoin = 'round'; this.ctx.strokeStyle = '#1e293b';
        if (this.mapPoints.length > 0) { this.ctx.moveTo(this.mapPoints[0].x, this.mapPoints[0].y); for (let i = 1; i < this.mapPoints.length; i++) this.ctx.lineTo(this.mapPoints[i].x, this.mapPoints[i].y); }
        this.ctx.stroke();
        this.ctx.beginPath(); this.ctx.lineWidth = 2; this.ctx.strokeStyle = 'rgba(56, 189, 248, 0.2)';
        if (this.mapPoints.length > 0) { this.ctx.moveTo(this.mapPoints[0].x, this.mapPoints[0].y); for (let i = 1; i < this.mapPoints.length; i++) this.ctx.lineTo(this.mapPoints[i].x, this.mapPoints[i].y); }
        this.ctx.stroke();

        this.towers.forEach(t => t.draw(this.ctx));
        this.enemies.forEach(e => e.draw(this.ctx));
        this.projectiles.forEach(p => p.draw(this.ctx));
        this.particles.forEach(p => p.draw(this.ctx));

        if (this.selectedTowerType && this.selectedTowerType !== 'sell' && !this.isGameOver && !this.isPaused) {
            const range = TOWERS[this.selectedTowerType].range;
            const valid = this.isValidBuildPosition(this.hoverTile.x, this.hoverTile.y);
            this.ctx.beginPath(); this.ctx.arc(this.hoverTile.x, this.hoverTile.y, range, 0, Math.PI * 2);
            this.ctx.fillStyle = valid ? 'rgba(255, 255, 255, 0.1)' : 'rgba(255, 0, 0, 0.2)'; this.ctx.fill();
            this.ctx.lineWidth = 1; this.ctx.strokeStyle = valid ? 'white' : 'red'; this.ctx.stroke();
            this.ctx.beginPath(); this.ctx.arc(this.hoverTile.x, this.hoverTile.y, 10, 0, Math.PI * 2);
            this.ctx.fillStyle = TOWERS[this.selectedTowerType].color; this.ctx.fill();
            
            if (this.freeBuild) {
                this.ctx.font = "bold 20px Gamja Flower";
                this.ctx.fillStyle = "#fff";
                this.ctx.fillText("FREE", this.hoverTile.x - 20, this.hoverTile.y - 20);
            }

            if (this.selectedTowerType === 'mortar') {
                this.ctx.beginPath(); this.ctx.arc(this.hoverTile.x, this.hoverTile.y, TOWERS['mortar'].minRange, 0, Math.PI * 2);
                this.ctx.strokeStyle = '#f43f5e'; this.ctx.setLineDash([5, 5]); this.ctx.stroke(); this.ctx.setLineDash([]);
            }
        }
        if (this.selectedTowerType === 'sell') {
            this.ctx.beginPath(); this.ctx.arc(this.mouse.x, this.mouse.y, 20, 0, Math.PI * 2);
            this.ctx.strokeStyle = '#ef4444'; this.ctx.lineWidth = 2; this.ctx.stroke();
            this.ctx.fillText("ğŸ—‘ï¸", this.mouse.x-7, this.mouse.y+5);
        }
    }

    gameLoop() {
        if (!this.isPlaying) return;
        
        // ë°°ì†ë§Œí¼ ì—…ë°ì´íŠ¸ ë°˜ë³µ
        for(let i=0; i<this.gameSpeed; i++) {
            this.update();
        }
        
        this.draw();
        requestAnimationFrame(() => this.gameLoop());
    }
}

// Enemy, Tower, Projectile, Particle í´ë˜ìŠ¤ëŠ” ì´ì „ê³¼ ë™ì¼ (ìƒëµí•˜ì§€ ì•ŠìŒ)
class Enemy {
    constructor(path, typeIdx, game) {
        this.path = path; this.pathIndex = 0; this.x = path[0].x; this.y = path[0].y;
        const data = ENEMIES[typeIdx];
        this.name = data.name;
        const waveMultiplier = 1 + (game.wave - 1) * 0.25;
        const diffMultiplier = game.difficultyMultiplier;
        this.maxHp = Math.floor(data.hp * waveMultiplier * diffMultiplier);
        this.hp = this.maxHp;
        this.baseSpeed = data.speed;
        this.speed = data.speed;
        this.reward = data.reward;
        this.color = data.color;
        this.radius = data.radius;
        this.isBreaker = data.isBreaker || false;
        this.damage = data.damage || 0;
        this.finished = false;
        this.targetTower = null;
        this.attackCooldown = 0;
        this.frozenTimer = 0;
        this.poisonTimer = 0; this.poisonDamage = 0;
        this.stopTimer = 0;
        this.cursedTimer = 0;
        this.goldBonus = 0;
        this.knockbackTimer = 0; 
    }

    takeDamage(amount, sourceTower) { 
        let dmg = amount;
        if (this.cursedTimer > 0) dmg *= 2; 
        this.hp -= dmg; 
        if (this.hp <= 0 && sourceTower) sourceTower.addKill();
    }

    freeze(frames) { this.frozenTimer = frames; }
    poison(frames, dmg) { this.poisonTimer = frames; this.poisonDamage = dmg; }
    curse(frames) { this.cursedTimer = frames; }
    pullBack(dist) { this.stopTimer = 60; }
    stop(frames) { this.stopTimer = frames; }
    knockback(frames) { this.knockbackTimer = frames; }

    update(game) {
        if (this.finished) return;

        if (this.stopTimer > 0) { this.stopTimer--; return; }
        
        let currentSpeed = this.baseSpeed;
        if (this.frozenTimer > 0) { currentSpeed *= 0.5; this.frozenTimer--; }
        
        if (this.knockbackTimer > 0) {
            currentSpeed = -1.5; 
            this.knockbackTimer--;
        }
        
        this.speed = currentSpeed;

        if (this.poisonTimer > 0) {
            this.takeDamage(this.poisonDamage, null); 
            this.poisonTimer--;
            if (this.poisonTimer % 20 === 0) game.createParticles(this.x, this.y, 1, '#4ade80');
        }
        if (this.cursedTimer > 0) this.cursedTimer--;

        if (this.isBreaker && this.knockbackTimer <= 0) { 
            if (this.targetTower) {
                if (this.targetTower.hp <= 0) this.targetTower = null;
                else {
                    this.attackCooldown++;
                    if (this.attackCooldown >= 10) {
                         this.targetTower.hp -= this.damage; 
                         this.attackCooldown = 0;
                         game.createParticles(this.targetTower.x, this.targetTower.y, 2, '#ffaa00');
                    }
                    return;
                }
            } else {
                let closest = null, minDist = 80;
                for (let t of game.towers) {
                    const dist = Math.hypot(t.x - this.x, t.y - this.y);
                    if (dist < minDist) { minDist = dist; closest = t; }
                }
                if (closest) { this.targetTower = closest; return; }
            }
        }

        let target;
        if (this.speed > 0) {
            target = this.path[this.pathIndex + 1];
            if (!target) { this.finished = true; return; }
        } else {
            target = this.path[this.pathIndex];
            if (!target) return; 
        }

        const dx = target.x - this.x, dy = target.y - this.y;
        const dist = Math.hypot(dx, dy);
        
        const moveDist = Math.abs(this.speed);
        
        if (dist < moveDist) {
            this.x = target.x; this.y = target.y; 
            if (this.speed > 0) {
                this.pathIndex++;
                if (this.pathIndex >= this.path.length - 1) this.finished = true;
            } else {
                if (this.pathIndex > 0) this.pathIndex--;
                else this.knockbackTimer = 0; 
            }
        } else {
            this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed;
        }
    }

    draw(ctx) {
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        if (this.stopTimer > 0) ctx.fillStyle = '#1e293b'; 
        else if (this.frozenTimer > 0) ctx.fillStyle = '#60a5fa';
        else if (this.poisonTimer > 0) ctx.fillStyle = '#4ade80';
        else if (this.cursedTimer > 0) ctx.fillStyle = '#581c87';
        else ctx.fillStyle = this.color;
        
        ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 10; ctx.fill(); ctx.shadowBlur = 0;

        if (this.isBreaker && this.targetTower) {
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.targetTower.x, this.targetTower.y);
            ctx.strokeStyle = '#ffaa00'; ctx.lineWidth = 2; ctx.stroke();
        }
        const hpPercent = this.hp / this.maxHp;
        if (hpPercent < 1) {
            ctx.fillStyle = 'red'; ctx.fillRect(this.x - 10, this.y - this.radius - 8, 20, 4);
            ctx.fillStyle = '#22c55e'; ctx.fillRect(this.x - 10, this.y - this.radius - 8, 20 * hpPercent, 4);
        }
        if (this.cursedTimer > 0) { ctx.font="10px Arial"; ctx.fillStyle="#fff"; ctx.fillText("â˜ ï¸", this.x-5, this.y-5); }
    }
}

class Tower {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type;
        const data = TOWERS[type];
        this.baseRange = data.range;
        this.baseDamage = data.damage;
        this.baseCooldown = data.cooldown;
        this.cooldownMax = data.cooldown;
        this.color = data.color;
        this.maxHp = data.cost * 4;
        this.minRange = data.minRange || 0; 
        
        this.hp = this.maxHp;
        this.range = this.baseRange;
        this.damage = this.baseDamage;
        this.cooldown = 0;
        this.angle = 0;
        this.firing = 0; 
        this.teslaTargets = [];
        this.level = 1;
        this.kills = 0;
        this.heat = 0; 
        this.speedBuff = 1.0;
    }

    resetBuffs() {
        const levelMult = 1 + (this.level - 1) * 0.3;
        this.damage = this.baseDamage * levelMult;
        if (this.type === 'soul') this.damage += this.kills; 
        
        this.range = this.baseRange * (1 + (this.level - 1) * 0.1); 
        this.speedBuff = 1.0;
    }

    applyBuff(towers, type, amount) {
        towers.forEach(t => {
            if (t === this) return;
            if (Math.hypot(t.x - this.x, t.y - this.y) <= this.range) {
                if (type === 'damage') t.damage *= amount; 
                if (type === 'speed') t.speedBuff *= amount; 
            }
        });
    }

    addKill() {
        this.kills++;
        if (this.kills >= CONFIG.EVOLUTION_KILLS * this.level) this.level++;
    }

    update(enemies, game) {
        if (this.cooldown > 0) this.cooldown--;
        if (this.firing > 0) this.firing--;

        if (this.type === 'minigun' && this.cooldown > 0) this.heat = Math.max(0, this.heat - 1);
        if (['buff','speed'].includes(this.type)) return;

        if (this.type === 'healer') {
            if (this.cooldown <= 0) {
                let targetTower = null;
                for (let t of game.towers) {
                    if (t === this) continue;
                    if (Math.hypot(t.x - this.x, t.y - this.y) <= this.range && t.hp < t.maxHp) {
                        targetTower = t; break;
                    }
                }
                if (targetTower) {
                    targetTower.hp = Math.min(targetTower.maxHp, targetTower.hp + 30);
                    this.cooldown = this.cooldownMax * this.speedBuff; this.firing = 10; this.healTarget = targetTower;
                }
            }
            return;
        }
        
        if (this.type === 'shock') {
            if (this.cooldown <= 0) {
                let hit = false;
                enemies.forEach(e => {
                    if (Math.hypot(e.x - this.x, e.y - this.y) <= this.range) {
                        e.takeDamage(this.damage, this); hit = true;
                    }
                });
                if (hit) {
                    this.firing = 5; 
                    this.cooldown = this.cooldownMax * this.speedBuff;
                }
            }
            return;
        }

        if (this.type === 'time') {
            if (this.cooldown <= 0) {
                let hit = false;
                enemies.forEach(e => {
                    if (Math.hypot(e.x - this.x, e.y - this.y) <= this.range) {
                        e.stop(60); hit = true;
                    }
                });
                if(hit) { this.firing = 10; this.cooldown = this.cooldownMax * this.speedBuff; }
            }
            return;
        }

        let target = null;
        
        if (this.type === 'railgun' || this.type === 'meteor') {
             for(const e of enemies) {
                if(Math.hypot(e.x - this.x, e.y - this.y) <= this.range) { target = e; break; }
            }
        } else {
            let minKeep = Infinity;
            for (const enemy of enemies) {
                const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                if (this.type === 'mortar' && dist < this.minRange) continue;
                
                if (dist <= this.range) {
                    if (dist < minKeep) { minKeep = dist; target = enemy; }
                }
            }
        }

        if (target) {
            this.angle = Math.atan2(target.y - this.y, target.x - this.x);
            
            if (this.cooldown <= 0) {
                if (this.type === 'laser') {
                    target.takeDamage(this.damage, this); this.firing = 2; return;
                }
                if (this.type === 'flame') {
                    enemies.forEach(e => { if (Math.hypot(e.x - this.x, e.y - this.y) <= this.range) e.takeDamage(this.damage, this); });
                    this.firing = 5; this.cooldown = this.cooldownMax * this.speedBuff; return;
                }
                if (this.type === 'execute') {
                    let dmg = this.damage;
                    if (target.hp / target.maxHp <= 0.3) dmg *= 3;
                    this.shoot(target, game, dmg);
                    this.cooldown = this.cooldownMax * this.speedBuff;
                    return;
                }
                if (this.type === 'railgun') {
                    const endX = this.x + Math.cos(this.angle) * this.range;
                    const endY = this.y + Math.sin(this.angle) * this.range;
                    enemies.forEach(e => {
                        if (game.distToSegment(e.x, e.y, this.x, this.y, endX, endY) < e.radius + 5) {
                            e.takeDamage(this.damage, this); game.createParticles(e.x, e.y, 5, '#06b6d4');
                        }
                    });
                    this.firing = 10; this.cooldown = this.cooldownMax * this.speedBuff; return;
                }
                if (this.type === 'tesla') {
                    this.teslaTargets = [target];
                    let current = target;
                    for(let i=0; i<2; i++) {
                        let next = null, nd = Infinity;
                        for(const e of enemies) {
                            if (this.teslaTargets.includes(e)) continue;
                            const d = Math.hypot(e.x - current.x, e.y - current.y);
                            if (d < 100 && d < nd) { nd = d; next = e; }
                        }
                        if (next) { this.teslaTargets.push(next); current = next; }
                    }
                    this.teslaTargets.forEach(e => { e.takeDamage(this.damage, this); game.createParticles(e.x, e.y, 3, '#a855f7'); });
                    this.firing = 10; this.cooldown = this.cooldownMax * this.speedBuff; return;
                }
                
                this.shoot(target, game, this.damage);
                
                if (this.type === 'minigun') {
                    this.heat = Math.min(10, this.heat + 1);
                    let cd = Math.max(2, this.cooldownMax - this.heat);
                    this.cooldown = cd * this.speedBuff;
                } else {
                    this.cooldown = this.cooldownMax * this.speedBuff;
                }
            }
        }
    }

    shoot(target, game, dmg) {
        if (this.type === 'multi') {
            game.projectiles.push(new Projectile(this.x, this.y, target, this.type, dmg, this));
        } else {
            game.projectiles.push(new Projectile(this.x, this.y, target, this.type, dmg, this));
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.fillStyle = '#334155'; ctx.fillRect(-12, -12, 24, 24);
        
        if (!['flame','healer','buff','time','shock','speed'].includes(this.type)) ctx.rotate(this.angle);
        
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color; ctx.shadowBlur = 10;
        
        if (this.type === 'splash') ctx.fillRect(-10, -10, 20, 20);
        else if (this.type === 'sniper') { ctx.fillRect(0, -3, 25, 6); ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill(); }
        else if (this.type === 'ice') { ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(8, 0); ctx.lineTo(0, 10); ctx.lineTo(-8, 0); ctx.fill(); }
        else if (this.type === 'laser') { ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-5, 5); ctx.lineTo(-5, -5); ctx.fill(); }
        else if (this.type === 'tesla') { ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill(); }
        else if (this.type === 'flame') { ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill(); }
        else if (this.type === 'railgun') { ctx.fillRect(0, -6, 20, 4); ctx.fillRect(0, 2, 20, 4); ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI*2); ctx.fill(); }
        else if (this.type === 'nuke' || this.type === 'mortar') { ctx.fillRect(-8, -8, 16, 16); ctx.fillStyle = this.type === 'mortar' ? '#333' : '#facc15'; ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill(); }
        else if (this.type === 'healer') { ctx.font = "20px Arial"; ctx.fillStyle="#fff"; ctx.fillText("âœš", -7, 7); }
        else if (this.type === 'buff' || this.type === 'speed') { 
            ctx.strokeStyle=this.color; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.stroke(); 
            ctx.font = "14px Arial"; ctx.fillStyle=this.color; ctx.fillText(this.type==='buff'?"â–²":"â©", -7, 5); 
        }
        else if (this.type === 'blackhole') { ctx.fillStyle="#000"; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill(); ctx.strokeStyle="#8b5cf6"; ctx.stroke(); }
        else if (this.type === 'poison') { ctx.font = "16px Arial"; ctx.fillStyle="#fff"; ctx.fillText("â˜ ï¸", -9, 5); }
        else if (this.type === 'execute') { ctx.fillStyle="#000"; ctx.fillRect(-5,-10,10,20); ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(0,0,5,0,Math.PI*2); ctx.fill(); }
        else if (this.type === 'prism') { ctx.beginPath(); ctx.moveTo(0,-10); ctx.lineTo(10,5); ctx.lineTo(-10,5); ctx.fill(); }
        else if (this.type === 'shock') { ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.stroke(); ctx.fillText("âš¡",-5,5); }
        else if (this.type === 'wind') { ctx.font = "16px Arial"; ctx.fillStyle="#fff"; ctx.fillText("ğŸ’¨", -9, 5); }
        else if (this.type === 'soul') { ctx.font = "14px Arial"; ctx.fillStyle="#fff"; ctx.fillText("ğŸ‘»", -7, 5); }
        else if (this.type === 'multi') { ctx.fillRect(0, -5, 12, 3); ctx.fillRect(0, 2, 12, 3); ctx.fillRect(0, -1, 15, 2); ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill(); }
        else if (this.type === 'minigun') { ctx.fillStyle="#94a3b8"; ctx.fillRect(0, -6, 18, 12); ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fill(); }
        else if (this.type === 'meteor') { ctx.fillStyle="#b91c1c"; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill(); }
        else if (this.type === 'curse') { ctx.font = "16px Arial"; ctx.fillStyle="#fff"; ctx.fillText("ğŸ”®", -9, 5); }
        else if (this.type === 'gold') { ctx.font = "16px Arial"; ctx.fillStyle="#fff"; ctx.fillText("ğŸ’°", -9, 5); }
        else if (this.type === 'time') { ctx.font = "16px Arial"; ctx.fillStyle="#fff"; ctx.fillText("â³", -9, 5); }
        else { ctx.fillRect(0, -4, 16, 8); ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill(); }
        
        ctx.shadowBlur = 0;

        if (this.type === 'laser' && this.firing > 0) { ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(this.range, 0); ctx.strokeStyle = this.color; ctx.lineWidth = 3; ctx.globalAlpha = 0.7; ctx.stroke(); ctx.globalAlpha = 1.0; }
        if (this.type === 'railgun' && this.firing > 0) { ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(this.range, 0); ctx.strokeStyle = '#cffafe'; ctx.lineWidth = 4; ctx.globalAlpha = 0.8; ctx.stroke(); ctx.lineWidth = 1; ctx.strokeStyle = '#06b6d4'; ctx.stroke(); ctx.globalAlpha = 1.0; }

        ctx.restore();

        if (this.type === 'healer' && this.firing > 0 && this.healTarget) {
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.healTarget.x, this.healTarget.y); ctx.strokeStyle = '#10b981'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
        }
        if (this.type === 'tesla' && this.firing > 0 && this.teslaTargets.length > 0) {
            ctx.beginPath(); ctx.strokeStyle = '#d8b4fe'; ctx.lineWidth = 2; ctx.moveTo(this.x, this.y);
            this.teslaTargets.forEach(t => { ctx.lineTo(t.x, t.y); }); ctx.stroke();
        }
        if ((this.type === 'flame' || this.type === 'time' || this.type === 'shock') && this.firing > 0) {
            ctx.beginPath(); 
            if(this.type==='flame') ctx.fillStyle = 'rgba(249, 115, 22, 0.3)';
            else if(this.type==='time') ctx.fillStyle = 'rgba(45, 212, 191, 0.3)';
            else ctx.fillStyle = 'rgba(253, 224, 71, 0.3)';
            ctx.arc(this.x, this.y, this.range, 0, Math.PI*2); ctx.fill();
        }

        if (this.level > 1) {
            ctx.font = "bold 12px Arial"; ctx.fillStyle = "#fbbf24"; ctx.fillText(`â­${this.level}`, this.x - 8, this.y - 15);
        }

        if (this.type === 'soul') {
             ctx.font = "10px Arial"; ctx.fillStyle = "#fff"; ctx.fillText(`+${this.kills}`, this.x - 5, this.y + 25);
        }

        if (this.hp < this.maxHp) {
            const hpPercent = Math.max(0, this.hp / this.maxHp);
            ctx.fillStyle = 'red'; ctx.fillRect(this.x - 12, this.y + 15, 24, 4);
            ctx.fillStyle = '#38bdf8'; ctx.fillRect(this.x - 12, this.y + 15, 24 * hpPercent, 4);
        }
    }
}

class Projectile {
    constructor(x, y, target, type, damage, owner) {
        this.x = x; this.y = y; this.target = target; this.type = type; this.damage = damage; this.owner = owner;
        this.speed = type === 'sniper' ? 15 : (['splash','nuke','blackhole','meteor','mortar'].includes(type) ? 4 : 8);
        this.life = 100;
        if (['splash','nuke','blackhole','meteor','mortar'].includes(type)) { this.tx = target.x; this.ty = target.y; this.target = null; }
    }
    update() {
        let tx, ty;
        if (this.target) {
            if (this.target.hp <= 0) { tx = this.target.x; ty = this.target.y; this.target = null; this.tx = tx; this.ty = ty; }
            else { tx = this.target.x; ty = this.target.y; }
        } else { tx = this.tx; ty = this.ty; }
        const dx = tx - this.x, dy = ty - this.y, dist = Math.hypot(dx, dy);
        if (dist < this.speed) { this.x = tx; this.y = ty; this.hit = true; }
        else { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
        this.life--;
    }
    hasReachedTarget() { return this.hit; }
    dealDamage(enemy) { enemy.takeDamage(this.damage, this.owner); }
    draw(ctx) {
        ctx.beginPath(); ctx.fillStyle = '#fff';
        if (this.type === 'splash') { ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fillStyle = '#f43f5e'; }
        else if (this.type === 'nuke') { ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.fillStyle = '#be123c'; }
        else if (this.type === 'mortar') { ctx.arc(this.x, this.y, 5, 0, Math.PI*2); ctx.fillStyle = '#713f12'; }
        else if (this.type === 'meteor') { ctx.arc(this.x, this.y, 8, 0, Math.PI*2); ctx.fillStyle = '#b91c1c'; }
        else if (this.type === 'blackhole') { ctx.arc(this.x, this.y, 5, 0, Math.PI*2); ctx.fillStyle = '#000'; ctx.strokeStyle='#8b5cf6'; ctx.stroke(); }
        else if (this.type === 'poison') { ctx.fillStyle = '#4ade80'; ctx.arc(this.x, this.y, 3, 0, Math.PI*2); }
        else if (this.type === 'curse') { ctx.fillStyle = '#581c87'; ctx.arc(this.x, this.y, 3, 0, Math.PI*2); }
        else if (this.type === 'gold') { ctx.fillStyle = '#fcd34d'; ctx.arc(this.x, this.y, 3, 0, Math.PI*2); }
        else if (this.type === 'ice') { ctx.fillStyle = '#60a5fa'; ctx.rect(this.x-3, this.y-3, 6, 6); }
        else if (this.type === 'wind') { ctx.fillStyle = '#bae6fd'; ctx.arc(this.x, this.y, 3, 0, Math.PI*2); }
        else ctx.arc(this.x, this.y, 2, 0, Math.PI*2);
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        const angle = Math.random() * Math.PI * 2, speed = Math.random() * 2 + 1;
        this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
        this.life = 1.0; this.decay = Math.random() * 0.03 + 0.02;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life -= this.decay; }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, 2, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1.0;
    }
}

window.onload = () => { const game = new Game(); };
</script>
</body>
</html>
